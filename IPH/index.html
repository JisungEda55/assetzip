<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iPhone 16 Pro Max Wallpaper Maker</title>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap">
    <style>
        /* SBAggroB Font Definition */
        @font-face {
            font-family: 'SBAggroB';
            src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2108@1.1/SBAggroB.woff') format('woff');
            font-weight: normal;
            font-style: normal;
        }

        :root {
            /* Material 3 Color Palette (using dynamic color concept) */
            --primary: #6200ee;
            --on-primary: #ffffff;
            --secondary: #03dac6;
            --on-secondary: #000000;
            --tertiary: #bb86fc; /* for accenting controls */
            --surface: #ffffff;
            --on-surface: #212121;
            --surface-variant: #e0e0e0;
            --on-surface-variant: #424242;
            --error: #b00020;
            --on-error: #ffffff;
            --outline: #757575;
            --shadow: rgba(0, 0, 0, 0.2);

            /* Widget specific colors */
            --widget-bg-color: rgba(0, 0, 0, 0.6); /* Default widget background */
            --widget-text-color: white; /* Default widget text color */
            --widget-selected-border: var(--primary); /* Selection outline color */
            --widget-resizer-color: var(--primary); /* Resizer handle color */

            /* Grid */
            --grid-color: rgba(0, 0, 0, 0.1);
            --grid-line-spacing: 20px; /* Default grid spacing */
        }

        body {
            font-family: 'Roboto', 'SBAggroB', sans-serif; /* Roboto for UI, SBAggroB for widgets/specific text */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: var(--surface-variant);
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: var(--on-surface);
        }

        #app-container {
            background-color: var(--surface);
            border-radius: 28px; /* More rounded for Material 3 feel */
            box-shadow: 0 10px 30px var(--shadow); /* Stronger, softer shadow */
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 25px;
            max-width: 95%;
            width: fit-content;
            transition: background-color 0.3s ease;
        }

        h1 {
            color: var(--on-surface);
            margin-bottom: 15px;
            font-size: 2.2em;
            text-align: center;
            font-weight: 700;
            font-family: 'SBAggroB', sans-serif; /* Explicitly use SBAggroB for title */
            letter-spacing: -0.03em;
        }

        #canvas-container {
            border: 2px solid var(--outline);
            background-color: #e9e9e9; /* Default placeholder, will be overwritten */
            border-radius: 18px; /* Slightly less than app container */
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.1);
            width: 330px; /* Scaled for display */
            height: 717px;
            max-width: 100%;
            max-height: 80vh;
            transition: background-color 0.3s ease; /* Smooth color transition */
            background-size: var(--grid-line-spacing) var(--grid-line-spacing);
            background-image:
                linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px);
        }

        #canvas-container.no-grid {
            background-image: none;
        }

        .material-symbols-outlined {
            font-variation-settings:
                'FILL' 0,
                'wght' 400,
                'GRAD' 0,
                'opsz' 24;
            font-size: 20px;
            vertical-align: middle;
        }
        .material-symbols-outlined.filled {
            font-variation-settings: 'FILL' 1;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 800px;
        }

        .control-group {
            background-color: var(--surface-variant);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group h3 {
            color: var(--on-surface);
            font-size: 1.2em;
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="file"] {
            display: none;
        }

        .button-style {
            background-color: var(--primary);
            color: var(--on-primary);
            padding: 12px 20px;
            border-radius: 12px; /* Material 3 button shape */
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.2s ease, transform 0.1s ease;
            font-weight: 500;
            text-align: center;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 1em;
            outline: none;
        }

        .button-style:hover {
            background-color: color-mix(in srgb, var(--primary) 90%, black);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.3);
            transform: translateY(-2px);
        }
        .button-style:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }
        .button-style.secondary-btn {
            background-color: var(--secondary);
            color: var(--on-secondary);
        }
        .button-style.secondary-btn:hover {
            background-color: color-mix(in srgb, var(--secondary) 90%, black);
            color: var(--on-secondary);
        }
        .button-style.tertiary-btn {
            background-color: var(--tertiary);
            color: var(--on-primary);
        }
        .button-style.tertiary-btn:hover {
            background-color: color-mix(in srgb, var(--tertiary) 90%, black);
        }
        .button-style:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        /* Text Input */
        input[type="text"] {
            padding: 12px 16px;
            border: 1px solid var(--outline);
            border-radius: 12px; /* Material 3 input shape */
            width: calc(100% - 32px);
            font-size: 1em;
            background-color: var(--surface);
            color: var(--on-surface);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            outline: none;
        }
        input[type="text"]:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px color-mix(in srgb, var(--primary) 20%, transparent);
        }

        /* Color Controls */
        #color-presets {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        .color-box {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }
        .color-box:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        .color-box.selected {
            border: 3px solid var(--primary); /* Stronger border for selection */
            transform: scale(1.05);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 45px;
            height: 45px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            border-radius: 50%;
            padding: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease, box-shadow 0.2s ease;
        }
        input[type="color"]::-webkit-color-swatch {
            border-radius: 50%;
            border: none;
        }
        input[type="color"]::-moz-color-swatch {
            border-radius: 50%;
            border: none;
        }
        input[type="color"]:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            background: var(--surface-variant);
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
        }
        input[type="range"]::-webkit-slider-thumb:active {
            cursor: grabbing;
        }


        /* Elements on canvas container */
        .movable-item {
            position: absolute;
            cursor: grab;
            user-select: none;
            box-sizing: border-box;
            touch-action: none; /* Prevent browser default touch behaviors like scrolling */
            transition: outline 0.1s ease; /* Smooth outline transition */
            z-index: 10; /* Default z-index */
            will-change: transform; /* Hint for browser optimization */
        }

        .movable-item.selected {
            outline: 2px solid var(--widget-selected-border);
            z-index: 1000; /* Bring selected item to front, higher than other elements' z-index */
        }

        .resizer {
            width: 20px; /* Larger for better touch target */
            height: 20px; /* Larger for better touch target */
            background: var(--widget-resizer-color);
            border: 3px solid var(--surface);
            position: absolute;
            right: -10px; /* Half of width/height */
            bottom: -10px; /* Half of width/height */
            cursor: se-resize;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease, opacity 0.2s ease;
            opacity: 0;
            pointer-events: none;
        }
        .movable-item.selected .resizer {
            opacity: 1; /* Show resizer when selected */
            pointer-events: auto;
        }

        .rotator {
            width: 20px;
            height: 20px;
            background: var(--tertiary);
            border: 3px solid var(--surface);
            position: absolute;
            left: 50%;
            top: -25px; /* Position above the item */
            transform: translateX(-50%);
            cursor: grab; /* Rotate cursor */
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: background 0.2s ease, opacity 0.2s ease;
        }
        .movable-item.selected .rotator {
            opacity: 1;
            pointer-events: auto;
        }


        .image-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            display: block;
            border-radius: 16px; /* Match Material 3 rounded corners */
        }
        .movable-item.image-preview-wrapper {
             /* Ensure image wrapper has rounded corners for effect */
            border-radius: 16px; 
            overflow: hidden; /* Clip image content to rounded corners */
        }

        /* Material 3 inspired widget style */
        .widget-box {
            background-color: var(--widget-bg-color);
            color: var(--widget-text-color);
            padding: 15px 20px; /* Slightly more padding */
            border-radius: 24px; /* Very rounded corners for M3 */
            font-size: 1.1em; /* Slightly larger default font */
            font-weight: 500; /* Medium weight */
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: pre-wrap;
            word-break: break-word;
            min-width: 80px;
            min-height: 40px;
            overflow: hidden;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); /* Soft, noticeable shadow */
            transition: box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease;
            font-family: 'SBAggroB', sans-serif; /* Apply SBAggroB to widgets */
            transform-origin: center center; /* For rotation */
            line-height: 1.3em; /* Default line height for widgets */
        }
        .widget-box.bold { font-weight: 700; }
        .widget-box.italic { font-style: italic; }
        .widget-box.underline { text-decoration: underline; }
        .widget-box.align-left { text-align: left; justify-content: flex-start; }
        .widget-box.align-center { text-align: center; justify-content: center; }
        .widget-box.align-right { text-align: right; justify-content: flex-end; }


        .widget-box.selected {
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3), 0 0 0 2px var(--widget-selected-border); /* Stronger shadow + outline when selected */
        }

        /* --- Preview Modal Styles --- */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 2000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(8px); /* Frosted glass effect */
            -webkit-backdrop-filter: blur(8px); /* Safari support */
            padding: 20px;
            box-sizing: border-box;
        }

        .modal-content {
            background-color: var(--surface);
            margin: auto;
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.5);
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            position: relative;
        }

        .modal-content img {
            max-width: 100%;
            max-height: calc(100vh - 120px); /* Adjust based on padding and close button */
            height: auto;
            border-radius: 12px;
            display: block; /* Remove extra space below image */
        }

        .close-button {
            position: absolute;
            top: 15px;
            right: 20px;
            color: var(--on-surface-variant);
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease, transform 0.2s ease;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }

        .close-button:hover,
        .close-button:focus {
            color: var(--primary);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            #app-container {
                padding: 20px;
                gap: 15px;
            }
            h1 {
                font-size: 1.8em;
            }
            .controls {
                grid-template-columns: 1fr;
            }
            .control-group {
                padding: 15px;
                gap: 10px;
            }
            .button-style {
                padding: 10px 15px;
                font-size: 0.9em;
            }
            .color-box, input[type="color"] {
                width: 32px;
                height: 32px;
            }
            .resizer, .rotator {
                width: 16px;
                height: 16px;
                right: -8px;
                bottom: -8px;
            }
            .rotator {
                top: -20px;
            }
            .modal-content {
                padding: 15px;
            }
            .close-button {
                top: 10px;
                right: 15px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1>iPhone 16 Pro Max Wallpaper Maker</h1>
        <div id="canvas-container">
            </div>

        <div class="controls">
            <div class="control-group">
                <h3><span class="material-symbols-outlined">palette</span> Background & Images</h3>
                <label for="imageUpload" class="button-style">
                    <span class="material-symbols-outlined">add_photo_alternate</span> Add Image (Max 4)
                </label>
                <input type="file" id="imageUpload" accept="image/*" multiple>

                <div>
                    <strong>Choose Background Color:</strong>
                    <div id="color-presets">
                        <div class="color-box" data-color="#ADD8E6" style="background-color: #ADD8E6;" title="Light Blue"></div>
                        <div class="color-box" data-color="#FFD1DC" style="background-color: #FFD1DC;" title="Light Pink"></div>
                        <div class="color-box" data-color="#B0E0E6" style="background-color: #B0E0E6;" title="Powder Blue"></div>
                        <div class="color-box" data-color="#90EE90" style="background-color: #90EE90;" title="Light Green"></div>
                        <div class="color-box" data-color="#FFFFB3" style="background-color: #FFFFB3;" title="Light Yellow"></div>
                        <input type="color" id="customBackgroundColor" value="#ADD8E6" title="Custom Color">
                    </div>
                </div>
                <div class="button-row">
                    <button id="flipHorizontalBtn" class="button-style tertiary-btn" title="Flip Horizontal (Image Only)"><span class="material-symbols-outlined">flip</span></button>
                    <button id="flipVerticalBtn" class="button-style tertiary-btn" title="Flip Vertical (Image Only)"><span class="material-symbols-outlined" style="transform: rotate(90deg);">flip</span></button>
                </div>
            </div>

            <div class="control-group">
                <h3><span class="material-symbols-outlined">text_fields</span> Text Widget</h3>
                <input type="text" id="widgetTextInput" placeholder="Enter widget text..." aria-label="Widget text input">
                <button id="addTextWidget" class="button-style secondary-btn">
                    <span class="material-symbols-outlined">add_box</span> Add Text Widget
                </button>
                <div class="button-row">
                    <button id="boldTextBtn" class="button-style tertiary-btn" title="Bold (B)"><span class="material-symbols-outlined">format_bold</span></button>
                    <button id="italicTextBtn" class="button-style tertiary-btn" title="Italic (I)"><span class="material-symbols-outlined">format_italic</span></button>
                    <button id="underlineTextBtn" class="button-style tertiary-btn" title="Underline (U)"><span class="material-symbols-outlined">format_underline</span></button>
                </div>
                <div class="button-row">
                    <button id="alignLeftBtn" class="button-style tertiary-btn" title="Align Left"><span class="material-symbols-outlined">format_align_left</span></button>
                    <button id="alignCenterBtn" class="button-style tertiary-btn" title="Align Center"><span class="material-symbols-outlined">format_align_center</span></button>
                    <button id="alignRightBtn" class="button-style tertiary-btn" title="Align Right"><span class="material-symbols-outlined">format_align_right</span></button>
                </div>
                <div>
                    <strong>Text Color:</strong>
                    <input type="color" id="widgetTextColor" value="#ffffff" title="Text Color">
                </div>
                <div>
                    <strong>Background Opacity:</strong>
                    <input type="range" id="widgetBgOpacity" min="0" max="1" step="0.05" value="0.6" title="Widget Background Opacity">
                </div>
            </div>

            <div class="control-group">
                <h3><span class="material-symbols-outlined">hand_tool</span> Tools & Actions</h3>
                <div class="button-row">
                    <button id="bringForwardBtn" class="button-style tertiary-btn" title="Bring Forward"><span class="material-symbols-outlined">flip_to_front</span></button>
                    <button id="sendBackwardBtn" class="button-style tertiary-btn" title="Send Backward"><span class="material-symbols-outlined">flip_to_back</span></button>
                    <button id="duplicateBtn" class="button-style tertiary-btn" title="Duplicate"><span class="material-symbols-outlined">content_copy</span></button>
                    <button id="deleteBtn" class="button-style tertiary-btn" title="Delete (Del/Backspace)"><span class="material-symbols-outlined">delete</span></button>
                </div>
                <div>
                    <strong>Grid Snapping:</strong>
                    <input type="range" id="gridSizeInput" min="0" max="50" step="5" value="20" title="Grid Size (0 for Off)">
                    <label style="font-size: 0.9em; margin-top: 5px;">Grid Size: <span id="gridSizeValue">20px</span> (0 = Off)</label>
                </div>
                <div class="button-row">
                    <button id="undoBtn" class="button-style tertiary-btn" title="Undo (Ctrl/Cmd+Z)"><span class="material-symbols-outlined">undo</span></button>
                    <button id="redoBtn" class="button-style tertiary-btn" title="Redo (Ctrl/Cmd+Y)"><span class="material-symbols-outlined">redo</span></button>
                </div>
                <div class="button-row">
                    <button id="previewWallpaper" class="button-style secondary-btn">
                        <span class="material-symbols-outlined">visibility</span> Preview Wallpaper
                    </button>
                    <button id="downloadWallpaper" class="button-style">
                        <span class="material-symbols-outlined">download</span> Download Wallpaper
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="previewModal" class="modal">
        <div class="modal-content">
            <button class="close-button material-symbols-outlined">close</button>
            <img id="previewImage" src="" alt="Generated Wallpaper Preview">
        </div>
    </div>

    <script>
        const canvas = document.createElement('canvas'); // Off-screen canvas for high-res download
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('imageUpload');
        const downloadWallpaperBtn = document.getElementById('downloadWallpaper');
        const previewWallpaperBtn = document.getElementById('previewWallpaper'); // New preview button
        const addTextWidgetBtn = document.getElementById('addTextWidget');
        const widgetTextInput = document.getElementById('widgetTextInput');
        const canvasContainer = document.getElementById('canvas-container');
        const colorPresets = document.getElementById('color-presets');
        const customBackgroundColorInput = document.getElementById('customBackgroundColor');
        const boldTextBtn = document.getElementById('boldTextBtn');
        const italicTextBtn = document.getElementById('italicTextBtn');
        const underlineTextBtn = document.getElementById('underlineTextBtn');
        const alignLeftBtn = document.getElementById('alignLeftBtn');
        const alignCenterBtn = document.getElementById('alignCenterBtn');
        const alignRightBtn = document.getElementById('alignRightBtn');
        const widgetTextColorInput = document.getElementById('widgetTextColor');
        const widgetBgOpacityInput = document.getElementById('widgetBgOpacity');
        const bringForwardBtn = document.getElementById('bringForwardBtn');
        const sendBackwardBtn = document.getElementById('sendBackwardBtn');
        const duplicateBtn = document.getElementById('duplicateBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
        const flipVerticalBtn = document.getElementById('flipVerticalBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridSizeValueSpan = document.getElementById('gridSizeValue');

        const previewModal = document.getElementById('previewModal'); // Preview modal element
        const previewImage = document.getElementById('previewImage');   // Image inside preview modal
        const closeModalBtn = previewModal.querySelector('.close-button'); // Close button for modal


        // iPhone 16 Pro Max Native Resolution
        const NATIVE_WIDTH = 1320; // in pixels
        const NATIVE_HEIGHT = 2868; // in pixels

        canvas.width = NATIVE_WIDTH;
        canvas.height = NATIVE_HEIGHT;

        let activeItem = null; // Currently selected item (HTML element)
        let isDragging = false;
        let isResizing = false;
        let isRotating = false;
        let initialPointerX, initialPointerY; // Initial pointer (mouse/touch) position
        let initialItemX, initialItemY;     // Initial item position on canvasContainer
        let initialItemWidth, initialItemHeight; // Initial item dimensions
        let initialItemRotation = 0; // Initial item rotation in degrees
        let rotationOriginX, rotationOriginY; // Center of the item for rotation

        // Store current background color
        let currentBackgroundColor = '#ADD8E6'; // Default light blue

        // Undo/Redo State Management
        let history = [];
        let historyPointer = -1;

        // Max images allowed
        const MAX_IMAGES = 4;

        // --- Utility Functions ---

        // Function to clamp a value between a min and max
        const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

        // Function to update UI colors based on background color (simple dynamic color concept)
        function updateUIColors(bgColor) {
            // A very simplified approach to derive accent colors.
            // In a real Material 3 app, this would involve a complex color algorithm.
            const r = parseInt(bgColor.slice(1, 3), 16);
            const g = parseInt(bgColor.slice(3, 5), 16);
            const b = parseInt(bgColor.slice(5, 7), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // Determine if text on this background should be light or dark
            const primaryColor = luminance > 0.5 ? '#6200ee' : '#bb86fc'; // Darker primary for light backgrounds, lighter for dark
            const selectedBorderColor = luminance > 0.5 ? '#007bff' : '#ffeb3b'; // Different selection color

            document.documentElement.style.setProperty('--primary', primaryColor);
            document.documentElement.style.setProperty('--widget-selected-border', selectedBorderColor);
            document.documentElement.style.setProperty('--widget-resizer-color', selectedBorderColor);
        }

        // --- History Management ---
        function saveState() {
            // Clear future history if we're not at the end
            if (historyPointer < history.length - 1) {
                history = history.slice(0, historyPointer + 1);
            }

            const state = [];
            canvasContainer.querySelectorAll('.movable-item').forEach(item => {
                const itemData = {
                    id: item.id,
                    type: item.dataset.type,
                    // Save the innerHTML for widgets to preserve text and style classes
                    // For images, only need the src and base properties
                    htmlContent: item.dataset.type === 'widget' ? item.innerHTML : null, 
                    src: item.dataset.type === 'image' ? item.querySelector('.image-preview').src : null, // Save image src
                    style: {
                        left: item.style.left,
                        top: item.style.top,
                        width: item.style.width,
                        height: item.style.height,
                        transform: item.style.transform, // Save current transform (for rotation/flip)
                        zIndex: item.style.zIndex,
                        // Widget specific styles
                        fontSize: item.style.fontSize,
                        backgroundColor: item.style.backgroundColor,
                        color: item.style.color,
                        fontWeight: item.style.fontWeight,
                        fontStyle: item.style.fontStyle,
                        textDecoration: item.style.textDecoration,
                        textAlign: item.style.textAlign,
                        justifyContent: item.style.justifyContent, // For flex alignment
                        opacity: item.style.opacity || '1' // Save opacity
                    },
                    classList: Array.from(item.classList), // Save classes for styling
                    textContent: item.textContent // For widgets, to ensure text content is accurate
                };
                state.push(itemData);
            });
            history.push({
                items: state,
                backgroundColor: currentBackgroundColor,
                activeItemId: activeItem ? activeItem.id : null
            });
            historyPointer++;
            updateUndoRedoButtons();
            // console.log("State saved:", historyPointer, history.length);
        }

        function restoreState(pointer) {
            if (pointer < 0 || pointer >= history.length) return;

            historyPointer = pointer;
            const state = history[historyPointer];

            // Clear current canvas container content
            canvasContainer.innerHTML = '';
            activeItem = null;

            // Restore background color
            setBackgroundColor(state.backgroundColor);
            customBackgroundColorInput.value = state.backgroundColor;
            document.querySelectorAll('.color-box').forEach(box => {
                if (box.dataset.color === state.backgroundColor) {
                    box.classList.add('selected');
                } else {
                    box.classList.remove('selected');
                }
            });

            // Restore items
            state.items.forEach(itemData => {
                let restoredItem;
                if (itemData.type === 'image') {
                    restoredItem = document.createElement('div');
                    restoredItem.className = 'movable-item image-preview-wrapper';
                    restoredItem.id = itemData.id;
                    restoredItem.dataset.type = 'image';

                    const imgElement = new Image(); // Use new Image() for proper loading
                    imgElement.src = itemData.src;
                    imgElement.className = 'image-preview';
                    
                    const resizer = document.createElement('div');
                    resizer.className = 'resizer';
                    const rotator = document.createElement('div');
                    rotator.className = 'rotator';

                    restoredItem.appendChild(imgElement);
                    restoredItem.appendChild(resizer);
                    restoredItem.appendChild(rotator);
                } else if (itemData.type === 'widget') {
                    restoredItem = document.createElement('div');
                    restoredItem.className = 'movable-item widget-box';
                    restoredItem.id = itemData.id;
                    restoredItem.dataset.type = 'widget';
                    restoredItem.innerHTML = itemData.htmlContent; // Restore innerHTML including resizer/rotator if present
                }
                
                // Restore classes
                restoredItem.classList = itemData.classList.join(' ');
                
                // Re-apply specific styles
                for (const prop in itemData.style) {
                    if (itemData.style[prop]) {
                        restoredItem.style[prop] = itemData.style[prop];
                    }
                }
                // Ensure text content is correct for widgets
                if (itemData.type === 'widget') {
                    restoredItem.textContent = itemData.textContent; // Overwrite innerHTML text if needed
                    // Re-add resizer and rotator if they were part of innerHTML for new widget
                    if (!restoredItem.querySelector('.resizer')) {
                        const resizer = document.createElement('div');
                        resizer.className = 'resizer';
                        restoredItem.appendChild(resizer);
                    }
                     if (!restoredItem.querySelector('.rotator')) {
                        const rotator = document.createElement('div');
                        rotator.className = 'rotator';
                        restoredItem.appendChild(rotator);
                    }
                }

                canvasContainer.appendChild(restoredItem);
                makeDraggableAndResizable(restoredItem); // Re-attach event listeners

                if (itemData.id === state.activeItemId) {
                    selectItem(restoredItem);
                }
            });

            updateUndoRedoButtons();
            updateImageUploadButton(); // Update button state after restore
            // console.log("State restored to:", historyPointer);
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = historyPointer <= 0;
            redoBtn.disabled = historyPointer >= history.length - 1;
        }

        function updateImageUploadButton() {
            const currentImagesCount = canvasContainer.querySelectorAll('.image-preview-wrapper').length;
            imageUpload.disabled = currentImagesCount >= MAX_IMAGES;
            imageUpload.parentElement.style.opacity = imageUpload.disabled ? '0.6' : '1';
            imageUpload.parentElement.style.cursor = imageUpload.disabled ? 'not-allowed' : 'pointer';
        }

        // --- Event Listeners ---

        // Image Upload
        imageUpload.addEventListener('change', (event) => {
            const files = Array.from(event.target.files);
            const currentImagesCount = canvasContainer.querySelectorAll('.image-preview-wrapper').length;
            const filesToAdd = files.slice(0, MAX_IMAGES - currentImagesCount);

            if (filesToAdd.length === 0 && files.length > 0) {
                alert(`You can only add up to ${MAX_IMAGES} images.`);
                return;
            }

            filesToAdd.forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const imgWrapper = document.createElement('div');
                        imgWrapper.className = 'movable-item image-preview-wrapper';
                        imgWrapper.id = `item-${Date.now()}`; // Unique ID for history
                        imgWrapper.dataset.type = 'image';
                        imgWrapper.style.zIndex = '1'; // Keep images behind new widgets by default (can be changed by user)

                        // Set initial size and position (e.g., a reasonable default)
                        const containerRect = canvasContainer.getBoundingClientRect();
                        const defaultImgWidth = Math.min(img.naturalWidth, containerRect.width * 0.6);
                        const defaultImgHeight = (img.naturalHeight / img.naturalWidth) * defaultImgWidth;
                        
                        const initialLeft = (containerRect.width / 2) - (defaultImgWidth / 2);
                        const initialTop = (containerRect.height / 2) - (defaultImgHeight / 2);

                        imgWrapper.style.width = `${defaultImgWidth}px`;
                        imgWrapper.style.height = `${defaultImgHeight}px`;
                        imgWrapper.style.left = `${initialLeft}px`;
                        imgWrapper.style.top = `${initialTop}px`;
                        
                        const imgElement = document.createElement('img');
                        imgElement.src = e.target.result;
                        imgElement.className = 'image-preview';
                        
                        const resizer = document.createElement('div');
                        resizer.className = 'resizer';
                        const rotator = document.createElement('div');
                        rotator.className = 'rotator';

                        imgWrapper.appendChild(imgElement);
                        imgWrapper.appendChild(resizer);
                        imgWrapper.appendChild(rotator);
                        canvasContainer.appendChild(imgWrapper);

                        makeDraggableAndResizable(imgWrapper);
                        selectItem(imgWrapper); 
                        saveState();
                        updateImageUploadButton();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
            event.target.value = ''; // Clear file input to allow re-uploading same files
        });

        // Add Text Widget
        addTextWidgetBtn.addEventListener('click', () => {
            const text = widgetTextInput.value.trim();
            if (text) {
                const newWidget = document.createElement('div');
                newWidget.className = 'movable-item widget-box';
                newWidget.id = `item-${Date.now()}`; // Unique ID for history
                newWidget.textContent = text;
                newWidget.dataset.type = 'widget';
                newWidget.style.zIndex = '2'; // Widgets above background image
                newWidget.style.backgroundColor = widgetBgOpacityInput.value ? `rgba(0, 0, 0, ${widgetBgOpacityInput.value})` : 'rgba(0,0,0,0.6)';
                newWidget.style.color = widgetTextColorInput.value || '#ffffff';
                newWidget.style.fontFamily = 'SBAggroB, sans-serif'; 
                newWidget.style.fontWeight = boldTextBtn.classList.contains('filled') ? '700' : '500';
                newWidget.style.fontStyle = italicTextBtn.classList.contains('filled') ? 'italic' : 'normal';
                newWidget.style.textDecoration = underlineTextBtn.classList.contains('filled') ? 'underline' : 'none';
                
                // Set initial text alignment based on current button states
                if (alignLeftBtn.classList.contains('filled')) {
                    newWidget.style.textAlign = 'left';
                    newWidget.style.justifyContent = 'flex-start';
                } else if (alignRightBtn.classList.contains('filled')) {
                    newWidget.style.textAlign = 'right';
                    newWidget.style.justifyContent = 'flex-end';
                } else { // Default to center
                    newWidget.style.textAlign = 'center';
                    newWidget.style.justifyContent = 'center';
                }

                // Set initial position (e.g., center of the canvas container display)
                const containerRect = canvasContainer.getBoundingClientRect();
                const initialWidth = 180; // default widget width
                const initialHeight = 60;  // default widget height
                
                const initialLeft = (containerRect.width / 2) - (initialWidth / 2);
                const initialTop = (containerRect.height / 2) - (initialHeight / 2);

                newWidget.style.left = `${initialLeft}px`;
                newWidget.style.top = `${initialTop}px`;
                newWidget.style.width = `${initialWidth}px`;
                newWidget.style.height = `${initialHeight}px`;

                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                const rotator = document.createElement('div');
                rotator.className = 'rotator';

                newWidget.appendChild(resizer);
                newWidget.appendChild(rotator);
                canvasContainer.appendChild(newWidget);

                makeDraggableAndResizable(newWidget);
                selectItem(newWidget); 
                widgetTextInput.value = ''; // Clear input
                saveState();
            }
        });

        // Download Wallpaper
        downloadWallpaperBtn.addEventListener('click', async () => {
            // Unselect any active item visually before rendering to canvas
            if (activeItem) {
                activeItem.classList.remove('selected');
            }
            activeItem = null; // Clear active item

            // Draw all current items to the off-screen canvas
            await drawFinalCanvas(); // Wait for drawing to complete

            const dataURL = canvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.href = dataURL;
            a.download = 'iphone_16_pro_max_wallpaper.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });

        // --- Preview Wallpaper Button ---
        previewWallpaperBtn.addEventListener('click', async () => {
            if (activeItem) {
                activeItem.classList.remove('selected');
            }
            activeItem = null;

            await drawFinalCanvas(); // Render the current state to the off-screen canvas

            const dataURL = canvas.toDataURL('image/png');
            previewImage.src = dataURL; // Set the image source for the modal
            previewModal.style.display = 'flex'; // Show the modal (CSS will center it)
        });

        // Close preview modal when clicking the close button
        closeModalBtn.addEventListener('click', () => {
            previewModal.style.display = 'none'; // Hide the modal
            previewImage.src = ''; // Clear image src
        });

        // Close preview modal when clicking outside the content
        previewModal.addEventListener('click', (e) => {
            if (e.target === previewModal) {
                previewModal.style.display = 'none';
                previewImage.src = '';
            }
        });


        // Background Color Selection
        colorPresets.addEventListener('click', (e) => {
            if (e.target.classList.contains('color-box')) {
                document.querySelectorAll('.color-box').forEach(box => box.classList.remove('selected'));
                e.target.classList.add('selected');
                
                const selectedColor = e.target.dataset.color;
                setBackgroundColor(selectedColor);
                customBackgroundColorInput.value = selectedColor;
                updateUIColors(selectedColor); 
                saveState();
            }
        });

        customBackgroundColorInput.addEventListener('input', (e) => {
            document.querySelectorAll('.color-box').forEach(box => box.classList.remove('selected'));
            setBackgroundColor(e.target.value);
            updateUIColors(e.target.value); 
            saveState();
        });

        function setBackgroundColor(color) {
            currentBackgroundColor = color;
            canvasContainer.style.backgroundColor = color;
        }

        // Widget Text Styling Controls
        boldTextBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.toggle('bold');
                activeItem.style.fontWeight = activeItem.classList.contains('bold') ? '700' : '500';
                boldTextBtn.classList.toggle('filled', activeItem.classList.contains('bold'));
                saveState();
            }
        });
        italicTextBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.toggle('italic');
                activeItem.style.fontStyle = activeItem.classList.contains('italic') ? 'italic' : 'normal';
                italicTextBtn.classList.toggle('filled', activeItem.classList.contains('italic'));
                saveState();
            }
        });
        underlineTextBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.toggle('underline');
                activeItem.style.textDecoration = activeItem.classList.contains('underline') ? 'underline' : 'none';
                underlineTextBtn.classList.toggle('filled', activeItem.classList.contains('underline'));
                saveState();
            }
        });
        alignLeftBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.remove('align-center', 'align-right');
                activeItem.classList.add('align-left');
                activeItem.style.textAlign = 'left';
                activeItem.style.justifyContent = 'flex-start';
                updateAlignButtonsState();
                saveState();
            }
        });
        alignCenterBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.remove('align-left', 'align-right');
                activeItem.classList.add('align-center');
                activeItem.style.textAlign = 'center';
                activeItem.style.justifyContent = 'center';
                updateAlignButtonsState();
                saveState();
            }
        });
        alignRightBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.classList.remove('align-left', 'align-center');
                activeItem.classList.add('align-right');
                activeItem.style.textAlign = 'right';
                activeItem.style.justifyContent = 'flex-end';
                updateAlignButtonsState();
                saveState();
            }
        });

        widgetTextColorInput.addEventListener('input', (e) => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                activeItem.style.color = e.target.value;
                saveState();
            }
        });

        widgetBgOpacityInput.addEventListener('input', (e) => {
            if (activeItem && activeItem.dataset.type === 'widget') {
                const currentBgColor = window.getComputedStyle(activeItem).backgroundColor;
                const match = currentBgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(,\s*(\d*\.?\d+))?\)/);
                if (match) {
                    activeItem.style.backgroundColor = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${e.target.value})`;
                } else {
                    activeItem.style.backgroundColor = `rgba(0,0,0,${e.target.value})`; // Fallback
                }
                saveState();
            }
        });

        // Layering controls
        bringForwardBtn.addEventListener('click', () => {
            if (activeItem) {
                const items = Array.from(canvasContainer.querySelectorAll('.movable-item'));
                let currentZ = parseInt(activeItem.style.zIndex) || 0;
                let newZ = currentZ;

                // Find all items with z-index greater than current and sort them
                const higherItems = items
                    .filter(item => (parseInt(item.style.zIndex) || 0) > currentZ && item !== activeItem)
                    .sort((a, b) => (parseInt(a.style.zIndex) || 0) - (parseInt(b.style.zIndex) || 0));

                if (higherItems.length > 0) {
                    // Move just above the lowest item that is higher than current
                    newZ = parseInt(higherItems[0].style.zIndex) || 0;
                } else {
                    // If no higher items, bring to front by setting a very high z-index
                    newZ = Math.max(...items.map(item => parseInt(item.style.zIndex) || 0)) + 1;
                }
                activeItem.style.zIndex = newZ;
                saveState();
            }
        });

        sendBackwardBtn.addEventListener('click', () => {
            if (activeItem) {
                const items = Array.from(canvasContainer.querySelectorAll('.movable-item'));
                let currentZ = parseInt(activeItem.style.zIndex) || 0;
                let newZ = currentZ;

                // Find all items with z-index less than current and sort them
                const lowerItems = items
                    .filter(item => (parseInt(item.style.zIndex) || 0) < currentZ && item !== activeItem)
                    .sort((a, b) => (parseInt(b.style.zIndex) || 0) - (parseInt(a.style.zIndex) || 0)); // Sort descending

                if (lowerItems.length > 0) {
                    // Move just below the highest item that is lower than current
                    newZ = parseInt(lowerItems[0].style.zIndex) || 0;
                } else {
                    // If no lower items, send to back by setting a very low z-index
                    newZ = Math.min(...items.map(item => parseInt(item.style.zIndex) || 0)) - 1;
                }
                activeItem.style.zIndex = newZ;
                saveState();
            }
        });

        // Duplicate
        duplicateBtn.addEventListener('click', () => {
            if (activeItem) {
                const clonedItem = activeItem.cloneNode(true);
                clonedItem.id = `item-${Date.now()}`; // New unique ID
                
                // Adjust position slightly to show it's a duplicate
                const currentLeft = parseFloat(activeItem.style.left);
                const currentTop = parseFloat(activeItem.style.top);
                clonedItem.style.left = `${currentLeft + 15}px`;
                clonedItem.style.top = `${currentTop + 15}px`;
                clonedItem.style.zIndex = (parseInt(activeItem.style.zIndex) || 0) + 1; // Bring duplicate slightly forward

                // Reset selection for the new clone
                clonedItem.classList.remove('selected');
                
                // Re-add event listeners for the cloned item
                makeDraggableAndResizable(clonedItem);
                canvasContainer.appendChild(clonedItem);
                selectItem(clonedItem); // Select the new duplicated item
                saveState();
                updateImageUploadButton(); // Update if an image was duplicated
            }
        });

        // Delete
        deleteBtn.addEventListener('click', () => {
            if (activeItem) {
                canvasContainer.removeChild(activeItem);
                activeItem = null;
                saveState();
                updateImageUploadButton(); // Update if an image was deleted
            }
        });

        // Flip Image
        flipHorizontalBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'image') {
                const currentTransform = activeItem.style.transform || '';
                const matrix = new DOMMatrixReadOnly(currentTransform);
                let newScaleX = matrix.m11;

                if (newScaleX < 0) { // Already flipped horizontally
                    newScaleX = 1;
                } else {
                    newScaleX = -1;
                }
                
                // Reconstruct transform string, preserving rotation
                let rotationMatch = currentTransform.match(/rotate\(([-]?\d*\.?\d*)deg\)/);
                let rotation = rotationMatch ? parseFloat(rotationMatch[1]) : 0;
                
                activeItem.style.transform = `scale(${newScaleX}, ${matrix.m22}) rotate(${rotation}deg)`;
                saveState();
            }
        });

        flipVerticalBtn.addEventListener('click', () => {
            if (activeItem && activeItem.dataset.type === 'image') {
                const currentTransform = activeItem.style.transform || '';
                const matrix = new DOMMatrixReadOnly(currentTransform);
                let newScaleY = matrix.m22;

                if (newScaleY < 0) { // Already flipped vertically
                    newScaleY = 1;
                } else {
                    newScaleY = -1;
                }

                // Reconstruct transform string, preserving rotation
                let rotationMatch = currentTransform.match(/rotate\(([-]?\d*\.?\d*)deg\)/);
                let rotation = rotationMatch ? parseFloat(rotationMatch[1]) : 0;
                
                activeItem.style.transform = `scale(${matrix.m11}, ${newScaleY}) rotate(${rotation}deg)`;
                saveState();
            }
        });

        // Undo/Redo
        undoBtn.addEventListener('click', () => restoreState(historyPointer - 1));
        redoBtn.addEventListener('click', () => restoreState(historyPointer + 1));

        // Keyboard shortcuts for Delete/Undo/Redo
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (activeItem) {
                    e.preventDefault(); // Prevent browser back navigation for backspace
                    canvasContainer.removeChild(activeItem);
                    activeItem = null;
                    saveState();
                    updateImageUploadButton();
                }
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                restoreState(historyPointer - 1);
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
                e.preventDefault();
                restoreState(historyPointer + 1);
            }
        });

        // Grid Size Control
        gridSizeInput.addEventListener('input', (e) => {
            const gridSize = parseInt(e.target.value);
            gridSizeValueSpan.textContent = `${gridSize}px`;
            if (gridSize === 0) {
                canvasContainer.classList.add('no-grid');
            } else {
                canvasContainer.classList.remove('no-grid');
                canvasContainer.style.setProperty('--grid-line-spacing', `${gridSize}px`);
                // Force redraw grid on background
                canvasContainer.style.backgroundImage = `
                    linear-gradient(to right, var(--grid-color) 1px, transparent 1px),
                    linear-gradient(to bottom, var(--grid-color) 1px, transparent 1px)
                `;
            }
        });

        // --- Drag, Resize, Rotate Core Logic ---
        function makeDraggableAndResizable(element) {
            const resizer = element.querySelector('.resizer');
            const rotator = element.querySelector('.rotator');

            const startInteraction = (e) => {
                if (!element) return;
                
                // Determine if it's a touch event or mouse event
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.touches[0].clientY;

                selectItem(element); 

                const rect = element.getBoundingClientRect();
                
                initialPointerX = clientX;
                initialPointerY = clientY;
                initialItemX = element.offsetLeft;
                initialItemY = element.offsetTop;
                initialItemWidth = rect.width;
                initialItemHeight = rect.height;
                
                // Get current transform matrix for rotation and scaling
                const computedTransform = window.getComputedStyle(element).transform;
                const matrix = new DOMMatrixReadOnly(computedTransform);
                
                initialItemRotation = Math.atan2(matrix.b, matrix.a) * (180 / Math.PI);
                
                // Calculate rotation origin (center of the element relative to the document)
                rotationOriginX = rect.left + rect.width / 2;
                rotationOriginY = rect.top + rect.height / 2;


                if (e.target === resizer) {
                    isResizing = true;
                    element.style.cursor = 'se-resize';
                } else if (e.target === rotator) {
                    isRotating = true;
                    element.style.cursor = 'crosshair'; 
                } else {
                    isDragging = true;
                    element.style.cursor = 'grabbing';
                }
                e.preventDefault(); 
                
                document.addEventListener('mousemove', moveInteraction);
                document.addEventListener('mouseup', endInteraction);
                document.addEventListener('touchmove', moveInteraction);
                document.addEventListener('touchend', endInteraction);
            };

            const moveInteraction = (e) => {
                if (!activeItem) return;

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - initialPointerX;
                const dy = clientY - initialPointerY;

                const containerRect = canvasContainer.getBoundingClientRect();
                const gridSize = parseInt(gridSizeInput.value);

                if (isDragging) {
                    let newLeft = initialItemX + dx;
                    let newTop = initialItemY + dy;

                    // Apply grid snapping
                    if (gridSize > 0) {
                        newLeft = Math.round(newLeft / gridSize) * gridSize;
                        newTop = Math.round(newTop / gridSize) * gridSize;
                    }

                    // Clamp to container boundaries
                    newLeft = clamp(newLeft, 0, containerRect.width - activeItem.offsetWidth);
                    newTop = clamp(newTop, 0, containerRect.height - activeItem.offsetHeight);

                    activeItem.style.left = `${newLeft}px`;
                    activeItem.style.top = `${newTop}px`;
                } else if (isResizing) {
                    let newWidth = initialItemWidth + dx;
                    let newHeight = initialItemHeight + dy;

                    // Apply grid snapping
                    if (gridSize > 0) {
                        newWidth = Math.round(newWidth / gridSize) * gridSize;
                        newHeight = Math.round(newHeight / gridSize) * gridSize;
                    }

                    // Ensure min width/height
                    newWidth = Math.max(80, newWidth);
                    newHeight = Math.max(40, newHeight);

                    // Clamp to container right/bottom edge
                    if (activeItem.offsetLeft + newWidth > containerRect.width) {
                        newWidth = containerRect.width - activeItem.offsetLeft;
                    }
                    if (activeItem.offsetTop + newHeight > containerRect.height) {
                        newHeight = containerRect.height - activeItem.offsetTop;
                    }

                    activeItem.style.width = `${newWidth}px`;
                    activeItem.style.height = `${newHeight}px`;

                    if (activeItem.dataset.type === 'widget') {
                        const currentCssFontSizePx = parseFloat(window.getComputedStyle(activeItem).fontSize);
                        const defaultWidgetWidth = 180; 
                        const defaultWidgetHeight = 60; 
                        
                        const widthRatio = newWidth / defaultWidgetWidth;
                        const heightRatio = newHeight / defaultWidgetHeight;
                        const scaleFactor = Math.min(widthRatio, heightRatio); 

                        const effectiveBaseFontSize = currentCssFontSizePx || 17; 
                        let newFontSize = effectiveBaseFontSize * scaleFactor;
                        newFontSize = clamp(newFontSize, 10, 50); 
                        activeItem.style.fontSize = `${newFontSize}px`;
                    }
                } else if (isRotating) {
                    const currentAngle = Math.atan2(clientY - rotationOriginY, clientX - rotationOriginX) * (180 / Math.PI);
                    const initialAngle = Math.atan2(initialPointerY - rotationOriginY, initialPointerX - rotationOriginX) * (180 / Math.PI);
                    
                    let newRotation = initialItemRotation + (currentAngle - initialAngle);

                    // Snap to 45-degree intervals if Shift key is pressed
                    if (e.shiftKey) {
                        newRotation = Math.round(newRotation / 45) * 45;
                    }
                    
                    // Get current transform values excluding rotation
                    const currentTransform = activeItem.style.transform || '';
                    const matrix = new DOMMatrixReadOnly(currentTransform);
                    let scaleX = matrix.m11 / Math.cos(initialItemRotation * Math.PI / 180); // Correctly extract scale even if rotated
                    let scaleY = matrix.m22 / Math.cos(initialItemRotation * Math.PI / 180);

                    // If scale values are very close to 0, default to 1 (e.g., if transform matrix is identity)
                    if (Math.abs(scaleX) < 0.001) scaleX = 1;
                    if (Math.abs(scaleY) < 0.001) scaleY = 1;


                    activeItem.style.transform = `scale(${scaleX}, ${scaleY}) rotate(${newRotation}deg)`;
                }
                requestAnimationFrame(() => {}); // Optimise updates
            };

            const endInteraction = () => {
                if (isDragging || isResizing || isRotating) {
                    saveState(); 
                }
                isDragging = false;
                isResizing = false;
                isRotating = false;
                if (activeItem) {
                    activeItem.style.cursor = 'grab'; 
                }
                document.removeEventListener('mousemove', moveInteraction);
                document.removeEventListener('mouseup', endInteraction);
                document.removeEventListener('touchmove', moveInteraction);
                document.removeEventListener('touchend', endInteraction);
            };

            element.addEventListener('mousedown', startInteraction);
            element.addEventListener('touchstart', startInteraction, { passive: false }); 
        }

        function selectItem(item) {
            if (activeItem && activeItem !== item) {
                activeItem.classList.remove('selected');
            }
            activeItem = item;
            item.classList.add('selected');
            
            // Update widget styling controls based on selected item's current state
            updateWidgetControls();
        }

        function updateWidgetControls() {
            // Disable all text/style controls by default
            const textControls = [boldTextBtn, italicTextBtn, underlineTextBtn, alignLeftBtn, alignCenterBtn, alignRightBtn, widgetTextColorInput, widgetBgOpacityInput];
            textControls.forEach(btn => {
                btn.disabled = true;
                btn.classList.remove('filled'); // Clear filled state
            });

            // Disable flip buttons by default
            flipHorizontalBtn.disabled = true;
            flipVerticalBtn.disabled = true;

            if (activeItem) {
                if (activeItem.dataset.type === 'widget') {
                    textControls.forEach(btn => btn.disabled = false);
                    
                    boldTextBtn.classList.toggle('filled', activeItem.classList.contains('bold') || activeItem.style.fontWeight === '700');
                    italicTextBtn.classList.toggle('filled', activeItem.classList.contains('italic') || activeItem.style.fontStyle === 'italic');
                    underlineTextBtn.classList.toggle('filled', activeItem.classList.contains('underline') || activeItem.style.textDecoration === 'underline');
                    
                    updateAlignButtonsState();

                    widgetTextColorInput.value = activeItem.style.color || '#ffffff';
                    const bgColorMatch = window.getComputedStyle(activeItem).backgroundColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(,\s*(\d*\.?\d+))?\)/);
                    widgetBgOpacityInput.value = bgColorMatch && bgColorMatch[5] !== undefined ? parseFloat(bgColorMatch[5]) : '0.6';

                } else if (activeItem.dataset.type === 'image') {
                    flipHorizontalBtn.disabled = false;
                    flipVerticalBtn.disabled = false;
                }
            }
        }

        function updateAlignButtonsState() {
            if (!activeItem || activeItem.dataset.type !== 'widget') return;
            
            const currentAlign = activeItem.style.textAlign || 'center'; // Default center
            alignLeftBtn.classList.toggle('filled', currentAlign === 'left');
            alignCenterBtn.classList.toggle('filled', currentAlign === 'center');
            alignRightBtn.classList.toggle('filled', currentAlign === 'right');
        }


        // Deselect item if click outside canvas container or control panel
        document.addEventListener('mousedown', (e) => {
            // Check if the click is outside canvasContainer, controls, AND the preview modal
            if (activeItem && 
                !activeItem.contains(e.target) && 
                !canvasContainer.contains(e.target) && 
                !e.target.closest('.controls') &&
                !previewModal.contains(e.target)) { 
                activeItem.classList.remove('selected');
                activeItem = null;
                updateWidgetControls(); // Disable controls when nothing is selected
            }
        });


        // --- Final Canvas Drawing for Download (High Resolution) ---
        async function drawFinalCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Always draw the current background color first
            ctx.fillStyle = currentBackgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const items = Array.from(canvasContainer.querySelectorAll('.movable-item'));
            // Sort items by z-index to ensure correct layering on canvas
            items.sort((a, b) => (parseInt(a.style.zIndex) || 0) - (parseInt(b.style.zIndex) || 0));

            const containerRect = canvasContainer.getBoundingClientRect();

            // Ensure font is loaded before drawing
            try {
                await document.fonts.ready;
            } catch (e) {
                console.warn("Font 'SBAggroB' might not be fully loaded for canvas rendering.", e);
            }
            const fontFamily = 'SBAggroB'; 

            for (const item of items) {
                const itemStyle = window.getComputedStyle(item);

                const scaleX_display_to_native = NATIVE_WIDTH / containerRect.width;
                const scaleY_display_to_native = NATIVE_HEIGHT / containerRect.height;

                let drawX_display = parseFloat(item.style.left);
                let drawY_display = parseFloat(item.style.top);
                let drawWidth_display = parseFloat(itemStyle.width);
                let drawHeight_display = parseFloat(itemStyle.height);

                // Calculate native coordinates and dimensions
                let drawX_native = drawX_display * scaleX_display_to_native;
                let drawY_native = drawY_display * scaleY_display_to_native;
                let drawWidth_native = drawWidth_display * scaleX_display_to_native;
                let drawHeight_native = drawHeight_display * scaleY_display_to_native;

                // Get rotation and scale from CSS transform matrix
                const transform = itemStyle.transform;
                let rotationAngle = 0; // in degrees
                let currentScaleX = 1;
                let currentScaleY = 1;

                if (transform && transform !== 'none') {
                    const matrix = new DOMMatrixReadOnly(transform);
                    // Extract rotation (in radians) and convert to degrees
                    rotationAngle = Math.atan2(matrix.b, matrix.a) * (180 / Math.PI);
                    
                    // Extract scale factors. Need to be careful if rotation is also present
                    // Correct way to get scale components:
                    currentScaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
                    currentScaleY = Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
                    
                    // Account for potential negative scale (flips)
                    if (matrix.a < 0 && matrix.b === 0) currentScaleX *= -1;
                    if (matrix.d < 0 && matrix.c === 0) currentScaleY *= -1;
                }

                ctx.save(); // Save current canvas state

                // Translate to the center of the item (on native canvas)
                ctx.translate(drawX_native + drawWidth_native / 2, drawY_native + drawHeight_native / 2);
                
                // Apply rotation
                ctx.rotate(rotationAngle * Math.PI / 180);
                
                // Apply scaling (for flip)
                ctx.scale(currentScaleX, currentScaleY); 

                // Translate back to draw position (relative to its own center now, but scaled and rotated)
                ctx.translate(-(drawX_native + drawWidth_native / 2), -(drawY_native + drawHeight_native / 2));
                
                if (item.dataset.type === 'image') {
                    const imgElement = item.querySelector('.image-preview');
                    if (imgElement && imgElement.naturalWidth > 0) {
                        const img = imgElement;
                        
                        // Implement object-fit: cover for canvas
                        const imgRatio = img.naturalWidth / img.naturalHeight;
                        const itemRatio = drawWidth_native / drawHeight_native;

                        let sx, sy, sWidth, sHeight; // Source rectangle
                        let dx, dy, dWidth, dHeight; // Destination rectangle

                        dx = drawX_native;
                        dy = drawY_native;
                        dWidth = drawWidth_native;
                        dHeight = drawHeight_native;

                        if (imgRatio > itemRatio) { // Image is wider than item, crop left/right
                            sHeight = img.naturalHeight;
                            sWidth = sHeight * itemRatio;
                            sx = (img.naturalWidth - sWidth) / 2;
                            sy = 0;
                        } else { // Image is taller than item, crop top/bottom
                            sWidth = img.naturalWidth;
                            sHeight = sWidth / itemRatio;
                            sy = (img.naturalHeight - sHeight) / 2;
                            sx = 0;
                        }
                        
                        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
                    }
                } else if (item.dataset.type === 'widget') {
                    const borderRadius = parseFloat(itemStyle.borderRadius) * scaleX_display_to_native;
                    const padding = parseFloat(itemStyle.paddingLeft) * scaleX_display_to_native;

                    ctx.fillStyle = itemStyle.backgroundColor; 
                    drawRoundedRect(ctx, drawX_native, drawY_native, drawWidth_native, drawHeight_native, borderRadius);

                    ctx.fillStyle = itemStyle.color;
                    const cssFontSize = parseFloat(itemStyle.fontSize);
                    const canvasFontSize = cssFontSize * scaleX_display_to_native;
                    
                    // Apply font styles for canvas
                    let fontStyle = itemStyle.fontStyle;
                    let fontWeight = itemStyle.fontWeight;
                    let textDecoration = itemStyle.textDecoration;
                    
                    ctx.font = `${fontStyle} ${fontWeight} ${canvasFontSize}px "${fontFamily}"`; 
                    ctx.textAlign = itemStyle.textAlign; 
                    ctx.textBaseline = 'middle';
                    
                    const textContent = item.textContent;
                    const lines = getWrappedTextLines(ctx, textContent, drawWidth_native - (padding * 2), canvasFontSize * 1.3, fontFamily, fontWeight, fontStyle); // Adjusted line height for canvas

                    let totalTextHeight = lines.length * (canvasFontSize * 1.3);
                    let startY_native;

                    // Adjust Y position based on text-align and widget height
                    if (itemStyle.justifyContent === 'flex-start') { // Corresponds to align-top
                        startY_native = drawY_native + padding + (canvasFontSize * 0.5); 
                    } else if (itemStyle.justifyContent === 'flex-end') { // Corresponds to align-bottom
                        startY_native = drawY_native + drawHeight_native - padding - totalTextHeight + (canvasFontSize * 0.5);
                    } else { // Center (default)
                        startY_native = drawY_native + (drawHeight_native / 2) - (totalTextHeight / 2) + (canvasFontSize * 0.5);
                    }
                    
                    lines.forEach((line, index) => {
                        let lineX_native;
                        if (ctx.textAlign === 'left') {
                            lineX_native = drawX_native + padding;
                        } else if (ctx.textAlign === 'right') {
                            lineX_native = drawX_native + drawWidth_native - padding;
                        } else { // center
                            lineX_native = drawX_native + drawWidth_native / 2;
                        }
                        ctx.fillText(line, lineX_native, startY_native + (index * (canvasFontSize * 1.3)));
                        
                        // Manually draw underline if needed (canvas does not automatically apply underline based on ctx.font)
                        if (textDecoration.includes('underline')) {
                            const textMetrics = ctx.measureText(line);
                            const underlineY_native = startY_native + (index * (canvasFontSize * 1.3)) + (canvasFontSize * 0.5); 
                            
                            let underlineXStart = lineX_native;
                            if (ctx.textAlign === 'center') {
                                underlineXStart = lineX_native - textMetrics.width / 2;
                            } else if (ctx.textAlign === 'right') {
                                underlineXStart = lineX_native - textMetrics.width;
                            }
                            ctx.beginPath();
                            ctx.strokeStyle = ctx.fillStyle; 
                            ctx.lineWidth = Math.max(1, canvasFontSize * 0.05); 
                            ctx.moveTo(underlineXStart, underlineY_native);
                            ctx.lineTo(underlineXStart + textMetrics.width, underlineY_native);
                            ctx.stroke();
                        }
                    });
                }
                ctx.restore(); // Restore canvas state for next item
            }
        }

        // Helper function to draw a rounded rectangle on canvas
        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // Helper function to wrap text for canvas, now considers font properties
        function getWrappedTextLines(ctx, text, maxWidth, lineHeight, fontFamily, fontWeight, fontStyle) {
            const words = text.split(' ');
            let lines = [];
            let currentLine = '';

            const originalFont = ctx.font;
            ctx.font = `${fontStyle} ${fontWeight} ${lineHeight * (0.9)}px "${fontFamily}"`; 

            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i] + (i < words.length - 1 ? ' ' : ''); 
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;

                if (testWidth > maxWidth && currentLine.length > 0) { // Ensure there's content to push to a new line
                    lines.push(currentLine.trim());
                    currentLine = words[i] + ' ';
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine.trim()); 
            ctx.font = originalFont; 
            return lines;
        }


        // --- Initialization ---
        // Set initial background color and update UI colors
        setBackgroundColor(currentBackgroundColor);
        customBackgroundColorInput.value = currentBackgroundColor;
        document.querySelector(`.color-box[data-color="${currentBackgroundColor}"]`).classList.add('selected');
        updateUIColors(currentBackgroundColor);

        // Initial save state
        saveState();
        updateUndoRedoButtons();
        updateWidgetControls(); // Initial state of controls (all disabled)
        updateImageUploadButton(); // Initial state for image upload button
    </script>
</body>
</html>